/************************************************************************/
/* QUASI88 --- PC-8801 emulator						*/
/*	Copyright (c) 1998-2012 Showzoh Fukunaga			*/
/*	All rights reserved.						*/
/*									*/
/*	  このソフトは、UNIX + X Window System の環境で動作する、	*/
/*	PC-8801 のエミュレータです。					*/
/*									*/
/*	  このソフトの作成にあたり、Marat Fayzullin氏作の fMSX、	*/
/*	Nicola Salmoria氏 (MAME/XMAME project) 作の MAME/XMAME、	*/
/*	ゆみたろ氏作の PC6001V のソースを参考にさせてもらいました。	*/
/*									*/
/*	＊注意＊							*/
/*	  サウンドドライバは、MAME/XMAME のソースを流用しています。	*/
/*	この部分のソースの著作権は、MAME/XMAME チームあるいはソースに	*/
/*	記載してある著作者にあります。					*/
/*	  FM音源ジェネレータは、fmgen のソースを流用しています。	*/
/*	この部分のソースの著作権は、 cisc氏 にあります。		*/
/*									*/
/************************************************************************/

#ifdef _CORES3
#include <M5Unified.h>
#elif defined _ATOMS3R
#include <lgfx.h>
#else
#include <M5Stack.h>
#endif
extern "C"
{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "quasi88.h"
#include "initval.h"
#include "pc88main.h"
#include "pc88sub.h"
#include "graph.h"
#include "screen.h"
#include "memory.h"

#include "file-op.h"

#include "emu.h"
#include "drive.h"
#include "event.h"
#include "keyboard.h"
#include "monitor.h"
#include "snddrv.h"
#include "wait.h"
#include "status.h"
#include "suspend.h"
#include "snapshot.h"
#include "soundbd.h"

#include "menu.h"
#include "pause.h"
#include "z80.h"
#include "intr.h"
}

int verbose_level = DEFAULT_VERBOSE; /* 冗長レベル		*/
int verbose_proc = FALSE;			 /* 処理の進行状況の表示	*/
int verbose_z80 = FALSE;			 /* Z80処理エラーを表示	*/
int verbose_io = FALSE;				 /* 未実装I/Oアクセス表示*/
int verbose_pio = FALSE;			 /* PIO の不正使用を表示 */
int verbose_fdc = FALSE;			 /* FDイメージ異常を報告	*/
int verbose_wait = FALSE;			 /* ウエイト時の異常を報告 */
int verbose_suspend = FALSE;		 /* サスペンド時の異常を報告 */
int verbose_snd = FALSE;			 /* サウンドのメッセージ	*/

static void imagefile_all_open(int stateload);
static void imagefile_all_close(void);
static void status_override(void);

/***********************************************************************
 *
 *			QUASI88 メイン関数
 *
 ************************************************************************/
void quasi88(void)
{
	quasi88_start();
	quasi88_main();
	quasi88_stop(TRUE);
}

/* =========================== メイン処理の初期化 ========================== */

#define SET_PROC(n)   \
	proc = n;         \
	if (verbose_proc) \
		printf("\n"); \
	fflush(NULL);
static int proc = 0;

void quasi88_start(void)
{
	Serial.println("Quasi88 Start");
	stateload_init(); /* ステートロード関連初期化	*/
	drive_init();	 /* ディスク制御のワーク初期化	*/
	/* ↑ これらは、ステートロード開始までに初期化しておくこと		*/

	SET_PROC(1);

	/* エミュレート用メモリの確保	*/
	if (memory_allocate() == FALSE)
	{
		quasi88_exit(-1);
	}

	if (resume_flag)
	{ /* ステートロード		*/
		SET_PROC(2);
		if (stateload() == FALSE)
		{
			fprintf(stderr, "stateload: Failed ! (filename = %s)\n",
					filename_get_state());
			quasi88_exit(-1);
		}
		if (verbose_proc)
			printf("Stateload...OK\n");
		fflush(NULL);
	}

	SET_PROC(3);
	/* グラフィックシステム初期化	*/
	if (screen_init() == FALSE)
	{
		quasi88_exit(-1);
	}
	SET_PROC(4);

	/* システムイベント初期化	*/
	event_init(); /* (screen_init の後で！)	*/
				  /* サウンドドライバ初期化	*/
	if (xmame_sound_start() == FALSE)
	{
		quasi88_exit(-1);
	}
	SET_PROC(5);
	/* ウエイト用タイマー初期化	*/
	if (wait_vsync_init() == FALSE)
	{
		quasi88_exit(-1);
	}
	SET_PROC(6);

	set_signal();					 /* INTシグナルの処理を設定	*/
	imagefile_all_open(resume_flag); /* イメージファイルを全て開く	*/
									 /* エミュ用ワークを順次初期化	*/
	pc88main_init((resume_flag) ? INIT_STATELOAD : INIT_POWERON);
	pc88sub_init((resume_flag) ? INIT_STATELOAD : INIT_POWERON);

	key_record_playback_init(); /* キー入力記録/再生 初期化	*/
	screen_snapshot_init();		/* スナップショット関連初期化   */

	debuglog_init();
	profiler_init();
	emu_breakpoint_init();
	quasi88_disk_eject_all();

  //drawEnable();
	if (verbose_proc)
		printf("Running QUASI88...\n");
	Serial.println("Running QUASI88...");
}

/* ======================== メイン処理のメインループ ======================= */

void quasi88_main(void)
{
	Serial.println("Quasi88 Main Start");
	for (;;)
	{

		/* 終了の応答があるまで、繰り返し呼び続ける */

		if (quasi88_loop() == QUASI88_LOOP_EXIT)
		{
			break;
		}
	}

	/* quasi88_loop() は、 1フレーム (VSYNC 1周期分≒1/60秒) おきに、
       QUASI88_LOOP_ONE を返してくる。
       この戻り値を判断して、なんらかの処理を加えてもよい。

       また、内部処理の事情で QUASI88_LOOP_BUSY を返してくることもあるが、
       この場合は気にせずに、繰り返し呼び出しを続行すること */
}

/* ========================== メイン処理の後片付け ========================= */

void quasi88_stop(int normal_exit)
{
	if (normal_exit)
	{
		if (verbose_proc)
			printf("Shutting down.....\n");
	}

	/* 初期化途中の場合、verbose による詳細表示がなければ、エラー表示する */
#define ERR_DISP(n) ((proc == (n)) && (verbose_proc == 0))

	switch (proc)
	{
	case 6: /* 初期化 正常に終わっている */
		profiler_exit();
		debuglog_exit();
		screen_snapshot_exit();
		key_record_playback_exit();
		pc88main_term();
		pc88sub_term();
		imagefile_all_close();
		wait_vsync_exit();
		/* FALLTHROUGH */

	case 5: /* タイマーの初期化でNG */
		if (ERR_DISP(5))
			printf("timer initialize failed!\n");
		xmame_sound_stop();
		/* FALLTHROUGH */

	case 4: /* サウンドの初期化でNG */
		if (ERR_DISP(4))
			printf("sound system initialize failed!\n");
		event_exit();
		screen_exit();
		/* FALLTHROUGH */

	case 3: /* グラフィックの初期化でNG */
		if (ERR_DISP(3))
			printf("graphic system initialize failed!\n");
		/* FALLTHROUGH */

	case 2: /* ステートロードでNG */
			/* FALLTHROUGH */

	case 1: /* メモリの初期化でNG */
		if (ERR_DISP(2))
			printf("memory allocate failed!\n");
		memory_free();
		/* FALLTHROUGH */

	case 0: /* 終了処理 すでに完了 */
		break;
	}

	proc = 0; /* この関数を続けて呼んでも問題無いように、クリアしておく */
}

/***********************************************************************
 * QUASI88 途中終了処理関数
 *	exit() の代わりに呼ぼう。
 ************************************************************************/

#define MAX_ATEXIT (32)
static void (*exit_function[MAX_ATEXIT])(void);

/*
 * 関数を最大 MAX_ATEXIT 個、登録できる。ここで登録した関数は、
 * quasi88_exit() を呼び出した時に、登録した順と逆順で、呼び出される。
 */
void quasi88_atexit(void (*function)(void))
{
	int i;
	for (i = 0; i < MAX_ATEXIT; i++)
	{
		if (exit_function[i] == NULL)
		{
			exit_function[i] = function;
			return;
		}
	}
	printf("quasi88_atexit: out of array\n");
	quasi88_exit(-1);
}

/*
 * quasi88 を強制終了する。
 * quasi88_atexit() で登録した関数を呼び出した後に、 exit() する
 */
void quasi88_exit(int status)
{
	int i;

	quasi88_stop(FALSE);

	for (i = MAX_ATEXIT - 1; i >= 0; i--)
	{
		if (exit_function[i])
		{
			(*exit_function[i])();
			exit_function[i] = NULL;
		}
	}

	exit(status);
}

/***********************************************************************
 * QUASI88メインループ制御
 *	QUASI88_LOOP_EXIT が返るまで、無限に呼び出すこと。
 * 戻り値
 *	QUASI88_LOOP_EXIT … 終了時
 *	QUASI88_LOOP_ONE  … 1フレーム経過時 (ウェイトが正確ならば約1/60秒周期)
 *	QUASI88_LOOP_BUSY … 上記以外の、なんらかのタイミング
 ************************************************************************/
int quasi88_event_flags = EVENT_MODE_CHANGED;
static int mode = EXEC;		 /* 現在のモード */
static int next_mode = EXEC; /* モード切替要求時の、次モード */

int quasi88_loop(void)
{
	static enum {
		INIT,
		MAIN,
		WAIT,
	} step = INIT,
	  step_after_wait = INIT;

	int stat;
	//Serial.println("LOOP Start");
	switch (step)
	{

	/* ======================== イニシャル処理 ======================== */
	case INIT:
		profiler_lapse(PROF_LAPSE_RESET);
		Serial.println("Initial");
		/* モード変更時は、必ずここに来る。モード変更フラグをクリア */
		quasi88_event_flags &= ~EVENT_MODE_CHANGED;
		mode = next_mode;

		/* 例外的なモード変更時の処理 */
		switch (mode)
		{
#ifndef USE_MONITOR
		case MONITOR: /* ありえないけど、念のため */
			mode = PAUSE;
			break;
#endif
		case QUIT: /* QUIT なら、メインループ終了 */
			return FALSE;
		}

		/* モード別イニシャル処理 */
		if (mode == EXEC)
		{
			xmame_sound_resume();
		}
		else
		{
			xmame_sound_suspend();
		}
		screen_switch();
		event_switch();
		keyboard_switch();

		switch (mode)
		{
		case EXEC:
			emu_init();
			break;

			//case MENU:	menu_init();		break;
#ifdef USE_MONITOR
		case MONITOR:
			monitor_init();
			break;
#endif
		case PAUSE:
			pause_init();
			break;
		}

		status_override();
		wait_vsync_switch();

		/* イニシャル処理が完了したら、MAIN に遷移 */
		step = MAIN;
		/* 遷移するため、一旦関数を抜ける (FALLTHROUGHでもいいけど) */
		return QUASI88_LOOP_BUSY;

	/* ======================== メイン処理 ======================== */
	case MAIN:
		switch (mode)
		{

		case EXEC:
			profiler_lapse(PROF_LAPSE_RESET);
			emu_main();
			break;
#ifdef USE_MONITOR
		case MONITOR:
			monitor_main();
			break;
#endif
			//case MENU:	menu_main();		break;

		case PAUSE:
			pause_main();
			break;
		}

		/* モード変更が発生していたら、(WAIT後に) INIT へ遷移する */
		/* そうでなければ、            (WAIT後に) MAIN へ遷移する */
		if (quasi88_event_flags & EVENT_MODE_CHANGED)
		{
			step_after_wait = INIT;
		}
		else
		{
			step_after_wait = MAIN;
		}

		/* 描画タイミングならばここで描画。その後 WAIT へ  */
		/* そうでなければ、                WAIT せずに遷移 */
		if (quasi88_event_flags & EVENT_FRAME_UPDATE)
		{
			quasi88_event_flags &= ~EVENT_FRAME_UPDATE;
			screen_update();
			step = WAIT;
		}
		else
		{
			step = step_after_wait;
		}

		/* モニター遷移時や終了時は、 WAIT せずに即ちに INIT へ */
		if (quasi88_event_flags & (EVENT_DEBUG | EVENT_QUIT))
		{
			step = INIT;
		}

		/* 遷移するため、一旦関数を抜ける (WAIT時はFALLTHROUGHでもいいけど) */
		return QUASI88_LOOP_BUSY;

	/* ======================== ウェイト処理 ======================== */
	case WAIT:
		stat = WAIT_JUST;

		switch (mode)
		{
		case EXEC:
			profiler_lapse(PROF_LAPSE_IDLE);
			if (!no_wait)
			{
				stat = wait_vsync_update();
			}
			break;

		case MENU:
		case PAUSE:
			/* Esound の場合、 MENU/PAUSE でも stream を流しておかないと
	       複数起動時に、 MENU/PAUSE してないほうが音がでなくなる。
	       が、このままだと、現在の音が流れっぱなしになるので、
	       無音を流すようにしないと。 */
			xmame_sound_update();			/* サウンド出力 */
			xmame_update_video_and_audio(); /* サウンド出力 その2 */
			stat = wait_vsync_update();
			break;
		}

		if (stat == WAIT_YET)
		{
			return QUASI88_LOOP_BUSY;
		}

		/* ウェイト時間を元に、フレームスキップの有無を決定 */
		if (mode == EXEC)
		{
			frameskip_check((stat == WAIT_JUST) ? TRUE : FALSE);
		}

		/* ウェイト処理が完了したら、次 (INIT か MAIN) に遷移 */
		step = step_after_wait;
		return QUASI88_LOOP_ONE;
	}

	/* ここには来ない ! */
	return QUASI88_LOOP_EXIT;
}

/*======================================================================
 * QUASI88 のモード制御
 *	モードとは QUASI88 の状態のことで、 EXEC (実行)、PAUSE (一時停止)、
 *	MENU (メニュー画面)、 MONITOR (対話型デバッガ)、 QUIT(終了) がある。
 *======================================================================*/
/* QUASI88のモードを設定する */
static void set_mode(int newmode)
{
	if (mode != newmode)
	{

		if (mode == MENU)
		{ /* メニューから他モードの切替は */
			//q8tk_event_quit();		/* Q8TK の終了が必須            */
		}

		next_mode = newmode;
		quasi88_event_flags |= EVENT_MODE_CHANGED;
		CPU_BREAKOFF();
	}
}

/* QUASI88のモードを切り替える */
void quasi88_exec(void)
{
	set_mode(EXEC);
	set_emu_exec_mode(GO);
}

void quasi88_exec_step(void)
{
	set_mode(EXEC);
	set_emu_exec_mode(STEP);
}

void quasi88_exec_trace(void)
{
	set_mode(EXEC);
	set_emu_exec_mode(TRACE);
}

void quasi88_exec_trace_change(void)
{
	set_mode(EXEC);
	set_emu_exec_mode(TRACE_CHANGE);
}

void quasi88_menu(void)
{
	set_mode(MENU);
}

void quasi88_pause(void)
{
	set_mode(PAUSE);
}

void quasi88_monitor(void)
{
#ifdef USE_MONITOR
	set_mode(MONITOR);
#else
	set_mode(PAUSE);
#endif
}

void quasi88_debug(void)
{
#ifdef USE_MONITOR
	set_mode(MONITOR);
	quasi88_event_flags |= EVENT_DEBUG;
#else
	set_mode(PAUSE);
#endif
}

void quasi88_quit(void)
{
	set_mode(QUIT);
	quasi88_event_flags |= EVENT_QUIT;
}

/* QUASI88のモードを取得する */
int quasi88_is_exec(void)
{
	return (mode == EXEC) ? TRUE : FALSE;
}
int quasi88_is_menu(void)
{
	return (mode == MENU) ? TRUE : FALSE;
}
int quasi88_is_pause(void)
{
	return (mode == PAUSE) ? TRUE : FALSE;
}
int quasi88_is_monitor(void)
{
	return (mode == MONITOR) ? TRUE : FALSE;
}

/***********************************************************************
 *	適切な位置に移動せよ
 ************************************************************************/
void wait_vsync_switch(void)
{
	long dt;

	/* dt < 1000000us (1sec) でないとダメ */
	if (quasi88_is_exec())
	{
		dt = (long)((1000000.0 / (CONST_VSYNC_FREQ * wait_rate / 100)));
		wait_vsync_setup(dt, wait_by_sleep);
	}
	else
	{
		dt = (long)(1000000.0 / CONST_VSYNC_FREQ);
		wait_vsync_setup(dt, TRUE);
	}
}

static void status_override(void)
{
	static int first_fime = TRUE;

	if (first_fime)
	{

		/* EMUモードで起動した場合のみ、ステータスの表示を変える */
		if (mode == EXEC)
		{

			status_message(0, STATUS_INFO_TIME, Q_TITLE " " Q_VERSION);

			if (resume_flag == 0)
			{
				if (status_imagename == FALSE)
				{
					//status_message_default(1, "<F12> key to MENU");
					status_message_default(1, "");
				}
			}
			else
			{
				status_message(1, STATUS_INFO_TIME, "State-Load Successful");
			}
		}
		first_fime = FALSE;
	}
}

/***********************************************************************
 *	デバッグ用
 ************************************************************************/
#include "debug.h"

/***********************************************************************
 *	雑多な関数
 ************************************************************************/
#include "utility.h"

/***********************************************************************
 *			ファイル名制御／管理
 ************************************************************************/
#include "fname.h"

/***********************************************************************
 * 各種動作パラメータの変更
 *	これらの関数は、ショートカットキー処理や、機種依存部のイベント
 *	処理などから呼び出されることを *一応* 想定している。
 *
 *	メニュー画面の表示中に呼び出すと、メニュー表示と食い違いが生じる
 *	ので、メニュー中は呼び出さないように。エミュ実行中に呼び出すのが
 *	一番安全。うーん、いまいち。
 *
 *	if( mode == EXEC ){
 *	    quasi88_disk_insert_and_reset( file, FALSE );
 *	}
 *
 ************************************************************************/

/***********************************************************************
 * QUASI88 起動中のリセット処理関数
 ************************************************************************/
void quasi88_get_reset_cfg(T_RESET_CFG *cfg)
{
	cfg->boot_basic = boot_basic;
	cfg->boot_dipsw = boot_dipsw;
	cfg->boot_from_rom = boot_from_rom;
	cfg->boot_clock_4mhz = boot_clock_4mhz;
	cfg->set_version = set_version;
	cfg->baudrate_sw = baudrate_sw;
	cfg->use_extram = use_extram;
	cfg->use_jisho_rom = use_jisho_rom;
	cfg->sound_board = sound_board;
}

void quasi88_reset(const T_RESET_CFG *cfg)
{
	int sb_changed = FALSE;
	int empty[2];

	if (verbose_proc)
		printf("Reset QUASI88...start\n");

	pc88main_term();
	pc88sub_term();

	if (cfg)
	{
		if (sound_board != cfg->sound_board)
		{
			sb_changed = TRUE;
		}

		boot_basic = cfg->boot_basic;
		boot_dipsw = cfg->boot_dipsw;
		boot_from_rom = cfg->boot_from_rom;
		boot_clock_4mhz = cfg->boot_clock_4mhz;
		set_version = cfg->set_version;
		baudrate_sw = cfg->baudrate_sw;
		use_extram = cfg->use_extram;
		use_jisho_rom = cfg->use_jisho_rom;
		sound_board = cfg->sound_board;
	}

	/* メモリの再確保が必要なら、処理する */
	if (memory_allocate_additional() == FALSE)
	{
		quasi88_exit(-1); /* 失敗！ */
	}

	/* サウンド出力のリセット */
	if (sb_changed == FALSE)
	{
		xmame_sound_reset();
	}
	else
	{
		//menu_sound_restart(FALSE);	/* サウンドドライバの再初期化 */
	}

	/* ワークの初期化 */
	pc88main_init(INIT_RESET);
	pc88sub_init(INIT_RESET);

	/* FDCの初期化 */
	empty[0] = drive_check_empty(0);
	empty[1] = drive_check_empty(1);
	drive_reset();
	if (empty[0])
		drive_set_empty(0);
	if (empty[1])
		drive_set_empty(1);

	/*if (xmame_has_sound()) xmame_sound_reset();*/

	emu_reset();

	if (verbose_proc)
		printf("Reset QUASI88...done\n");
}

/***********************************************************************
 * QUASI88 起動中のステートロード処理関数
 *	TODO 引数で、ファイル名指定？
 ************************************************************************/
int quasi88_stateload(int serial)
{
	int now_board, success;

	if (serial >= 0)
	{									   /* 連番指定あり (>=0) なら */
		filename_set_state_serial(serial); /* 連番を設定する */
	}

	if (verbose_proc)
		printf("Stateload...start (%s)\n", filename_get_state());

	if (stateload_check_file_exist() == FALSE)
	{ /* ファイルなし */
		if (quasi88_is_exec())
		{
			status_message(1, STATUS_INFO_TIME, "State-Load file not found !");
		} /* メニューではダイアログ表示するので、ステータス表示は無しにする */

		if (verbose_proc)
			printf("State-file not found\n");
		return FALSE;
	}

	pc88main_term(); /* 念のため、ワークを終了状態に */
	pc88sub_term();
	imagefile_all_close(); /* イメージファイルを全て閉じる */

	/*xmame_sound_reset();*/ /* 念のため、サウンドリセット */
	/*quasi88_reset();*/	 /* 念のため、全ワークリセット */

	now_board = sound_board;

	success = stateload(); /* ステートロード実行 */

	if (now_board != sound_board)
	{   /* サウンドボードが変わったら */
		//menu_sound_restart(FALSE);	/* サウンドドライバの再初期化 */
	}

	if (verbose_proc)
	{
		if (success)
			printf("Stateload...done\n");
		else
			printf("Stateload...Failed, Reset start\n");
	}

	if (success)
	{ /* ステートロード成功したら・・・ */

		imagefile_all_open(TRUE); /* イメージファイルを全て開く*/

		pc88main_init(INIT_STATELOAD);
		pc88sub_init(INIT_STATELOAD);
	}
	else
	{ /* ステートロード失敗したら・・・ */

		quasi88_reset(NULL); /* とりあえずリセット */
	}

	if (quasi88_is_exec())
	{
		if (success)
		{
			status_message(1, STATUS_INFO_TIME, "State-Load Successful");
		}
		else
		{
			status_message(1, STATUS_INFO_TIME, "State-Load Failed !  Reset done ...");
		}

		/* quasi88_loop の内部状態を INIT にするため、モード変更扱いとする */
		quasi88_event_flags |= EVENT_MODE_CHANGED;
	}
	/* メニューではダイアログ表示するので、ステータス表示は無しにする */

	return success;
}

/***********************************************************************
 * QUASI88 起動中のステートセーブ処理関数
 *	TODO 引数で、ファイル名指定？
 ************************************************************************/
int quasi88_statesave(int serial)
{
	int success;

	if (serial >= 0)
	{									   /* 連番指定あり (>=0) なら */
		filename_set_state_serial(serial); /* 連番を設定する */
	}

	if (verbose_proc)
		printf("Statesave...start (%s)\n", filename_get_state());

	success = statesave(); /* ステートセーブ実行 */

	if (verbose_proc)
	{
		if (success)
			printf("Statesave...done\n");
		else
			printf("Statesave...Failed, Reset done\n");
	}

	if (quasi88_is_exec())
	{
		if (success)
		{
			status_message(1, STATUS_INFO_TIME, "State-Save Successful");
		}
		else
		{
			status_message(1, STATUS_INFO_TIME, "State-Save Failed !");
		}
	} /* メニューではダイアログ表示するので、ステータス表示は無しにする */

	return success;
}

/***********************************************************************
 * 画面スナップショット保存
 *	TODO 引数で、ファイル名指定？
 ************************************************************************/
int quasi88_screen_snapshot(void)
{
	int success;

	success = screen_snapshot_save();

	if (success)
	{
		status_message(1, STATUS_INFO_TIME, "Screen Capture Saved");
	}
	else
	{
		status_message(1, STATUS_INFO_TIME, "Screen Capture Failed !");
	}

	return success;
}

/***********************************************************************
 * サウンドデータのファイル出力
 *	TODO 引数で、ファイル名指定？
 ************************************************************************/
int quasi88_waveout(int start)
{
	int success;

	if (start)
	{
		success = waveout_save_start();

		if (success)
		{
			status_message(1, STATUS_INFO_TIME, "Sound Record Start ...");
		}
		else
		{
			status_message(1, STATUS_INFO_TIME, "Sound Record Failed !");
		}
	}
	else
	{

		success = TRUE;

		waveout_save_stop();
		status_message(1, STATUS_INFO_TIME, "Sound Record Stopped");
	}

	return success;
}

/***********************************************************************
 * ドラッグアンドドロップ
 *	TODO 戻り値をもう一工夫
 ************************************************************************/
int quasi88_drag_and_drop(const char *filename)
{
	if (quasi88_is_exec() ||
		quasi88_is_pause())
	{

		if (quasi88_disk_insert_all(filename, FALSE))
		{

			status_message(1, STATUS_INFO_TIME, "Disk Image Set and Reset");
			quasi88_reset(NULL);

			if (quasi88_is_pause())
			{
				quasi88_exec();
			}
		}
		else
		{

			status_message(1, STATUS_WARN_TIME, "D&D Failed !  Disk Unloaded ...");
		}

		return TRUE;
	}

	return FALSE;
}

/***********************************************************************
 * ウェイトの比率設定
 * ウェイトの有無設定
 ************************************************************************/
int quasi88_cfg_now_wait_rate(void)
{
	return wait_rate;
}
void quasi88_cfg_set_wait_rate(int rate)
{
	int time = STATUS_INFO_TIME;
	char str[32];
	long dt;

	if (rate < 5)
		rate = 5;
	if (rate > 5000)
		rate = 5000;

	if (wait_rate != rate)
	{
		wait_rate = rate;

		if (quasi88_is_exec())
		{

			sprintf(str, "WAIT  %4d[%%]", wait_rate);

			status_message(1, time, str);
			/* ↑ ウェイト変更したので、表示時間はウェイト倍になる */

			dt = (long)((1000000.0 / (CONST_VSYNC_FREQ * wait_rate / 100)));
			wait_vsync_setup(dt, wait_by_sleep);
		}
	}
}
int quasi88_cfg_now_no_wait(void)
{
	return no_wait;
}
void quasi88_cfg_set_no_wait(int enable)
{
	int time = STATUS_INFO_TIME;
	char str[32];
	long dt;

	if (no_wait != enable)
	{
		no_wait = enable;

		if (quasi88_is_exec())
		{

			if (no_wait)
			{
				sprintf(str, "WAIT  OFF");
				time *= 10;
			}
			else
				sprintf(str, "WAIT  ON");

			status_message(1, time, str);
			/* ↑ ウェイトなしなので、表示時間は実際のところ不定 */

			dt = (long)((1000000.0 / (CONST_VSYNC_FREQ * wait_rate / 100)));
			wait_vsync_setup(dt, wait_by_sleep);
		}
	}
}

/***********************************************************************
 * ディスクイメージファイル設定
 *	・両ドライブに挿入
 *	・指定ドライブに挿入
 *	・反対ドライブのイメージファイルを、挿入
 *	・両ドライブ取り出し
 *	・指定ドライブ取り出し
 ************************************************************************/
int quasi88_disk_insert_all(const char *filename, int ro)
{
	int success;

	quasi88_disk_eject_all();

	success = quasi88_disk_insert(DRIVE_1, filename, 0, ro);

	if (success)
	{

		if (disk_image_num(DRIVE_1) > 1)
		{
			quasi88_disk_insert_A_to_B(DRIVE_1, DRIVE_2, 1);
		}
	}

	if (quasi88_is_exec())
	{
		status_message_default(1, NULL);
	}
	return success;
}
int quasi88_disk_insert(int drv, const char *filename, int image, int ro)
{
	int success = FALSE;
	quasi88_disk_eject(drv);

	if (strlen(filename) < QUASI88_MAX_FILENAME)
	{
		if (disk_insert(drv, filename, image, ro) == 0){
			success = TRUE;
		}
		else
		{
			success = FALSE;
		}

		
		if (success)
		{

			if (drv == DRIVE_1)
				boot_from_rom = FALSE;

			strcpy(file_disk[drv], filename);
			readonly_disk[drv] = ro;

			if (filename_synchronize)
			{
				filename_init_state(TRUE);
				filename_init_snap(TRUE);
				filename_init_wav(TRUE);
			}
		}
	}

	if (quasi88_is_exec())
	{
		status_message_default(1, NULL);
	}
	return success;
}
int quasi88_disk_insert_A_to_B(int src, int dst, int img)
{
	int success;

	quasi88_disk_eject(dst);

	if (disk_insert_A_to_B(src, dst, img) == 0)
		success = TRUE;
	else
		success = FALSE;

	if (success)
	{
		strcpy(file_disk[dst], file_disk[src]);
		readonly_disk[dst] = readonly_disk[src];

		if (filename_synchronize)
		{
			filename_init_state(TRUE);
			filename_init_snap(TRUE);
			filename_init_wav(TRUE);
		}
	}

	if (quasi88_is_exec())
	{
		status_message_default(1, NULL);
	}
	return success;
}
void quasi88_disk_eject_all(void)
{
	int drv;

	for (drv = 0; drv < 2; drv++)
	{
		quasi88_disk_eject(drv);
	}

	boot_from_rom = TRUE;

	if (quasi88_is_exec())
	{
		status_message_default(1, NULL);
	}
}
void quasi88_disk_eject(int drv)
{
	if (disk_image_exist(drv))
	{
		disk_eject(drv);
		memset(file_disk[drv], 0, QUASI88_MAX_FILENAME);

		if (filename_synchronize)
		{
			filename_init_state(TRUE);
			filename_init_snap(TRUE);
			filename_init_wav(TRUE);
		}
	}

	if (quasi88_is_exec())
	{
		status_message_default(1, NULL);
	}
}

/***********************************************************************
 * ディスクイメージファイル設定
 *	・ドライブを一時的に空の状態にする
 *	・ドライブのイメージを変更する
 *	・ドライブのイメージを前のイメージに変更する
 *	・ドライブのイメージを次のイメージに変更する
 ************************************************************************/
enum
{
	TYPE_SELECT,
	TYPE_EMPTY,
	TYPE_NEXT,
	TYPE_PREV
};

static void disk_image_sub(int drv, int type, int img)
{
	int d;
	char str[48];

	if (disk_image_exist(drv))
	{
		switch (type)
		{

		case TYPE_EMPTY:
			drive_set_empty(drv);
			sprintf(str, "DRIVE %d:  <<<< Eject >>>>         ", drv + 1);
			break;

		case TYPE_NEXT:
		case TYPE_PREV:
			if (type == TYPE_NEXT)
				d = +1;
			else
				d = -1;

			img = disk_image_selected(drv) + d;
			/* FALLTHROUGH */

		default:
			if (img < 0)
				img = disk_image_num(drv) - 1;
			if (img >= disk_image_num(drv))
				img = 0;

			drive_unset_empty(drv);
			disk_change_image(drv, img);

			sprintf(str, "DRIVE %d:  %-16s   %s  ",
					drv + 1,
					drive[drv].image[disk_image_selected(drv)].name,
					(drive[drv].image[disk_image_selected(drv)].protect)
						? "(p)"
						: "   ");
			break;
		}
	}
	else
	{
		sprintf(str, "DRIVE %d:   --  No Disk  --        ", drv + 1);
	}

	if (quasi88_is_exec())
	{
		status_message_default(1, NULL);
	}
	status_message(1, STATUS_INFO_TIME, str);
}
void quasi88_disk_image_select(int drv, int img)
{
	disk_image_sub(drv, TYPE_SELECT, img);
}
void quasi88_disk_image_empty(int drv)
{
	disk_image_sub(drv, TYPE_EMPTY, 0);
}
void quasi88_disk_image_next(int drv)
{
	disk_image_sub(drv, TYPE_NEXT, 0);
}
void quasi88_disk_image_prev(int drv)
{
	disk_image_sub(drv, TYPE_PREV, 0);
}

/*======================================================================
 * テープイメージファイル設定
 *		・ロード用テープイメージファイルセット
 *		・ロード用テープイメージファイル巻き戻し
 *		・ロード用テープイメージファイル取り外し
 *		・セーブ用テープイメージファイルセット
 *		・セーブ用テープイメージファイル取り外し
 *======================================================================*/
int quasi88_load_tape_insert(const char *filename)
{
	quasi88_load_tape_eject();

	if (strlen(filename) < QUASI88_MAX_FILENAME &&
		sio_open_tapeload(filename))
	{

		strcpy(file_tape[CLOAD], filename);
		return TRUE;
	}
	return FALSE;
}
int quasi88_load_tape_rewind(void)
{
	if (sio_tape_rewind())
	{

		return TRUE;
	}
	quasi88_load_tape_eject();
	return FALSE;
}
void quasi88_load_tape_eject(void)
{
	sio_close_tapeload();
	memset(file_tape[CLOAD], 0, QUASI88_MAX_FILENAME);
}

int quasi88_save_tape_insert(const char *filename)
{
	quasi88_save_tape_eject();

	if (strlen(filename) < QUASI88_MAX_FILENAME &&
		sio_open_tapesave(filename))
	{

		strcpy(file_tape[CSAVE], filename);
		return TRUE;
	}
	return FALSE;
}
void quasi88_save_tape_eject(void)
{
	sio_close_tapesave();
	memset(file_tape[CSAVE], 0, QUASI88_MAX_FILENAME);
}

/*======================================================================
 * シリアル・パラレルイメージファイル設定
 *		・シリアル入力用ファイルセット
 *		・シリアル入力用ファイル取り外し
 *		・シリアル出力用ファイルセット
 *		・シリアル出力用ファイル取り外し
 *		・プリンタ出力用ファイルセット
 *		・プリンタ入力用ファイルセット
 *======================================================================*/
int quasi88_serial_in_connect(const char *filename)
{
	quasi88_serial_in_remove();

	if (strlen(filename) < QUASI88_MAX_FILENAME &&
		sio_open_serialin(filename))
	{

		strcpy(file_sin, filename);
		return TRUE;
	}
	return FALSE;
}
void quasi88_serial_in_remove(void)
{
	sio_close_serialin();
	memset(file_sin, 0, QUASI88_MAX_FILENAME);
}
int quasi88_serial_out_connect(const char *filename)
{
	quasi88_serial_out_remove();

	if (strlen(filename) < QUASI88_MAX_FILENAME &&
		sio_open_serialout(filename))
	{

		strcpy(file_sout, filename);
		return TRUE;
	}
	return FALSE;
}
void quasi88_serial_out_remove(void)
{
	sio_close_serialout();
	memset(file_sout, 0, QUASI88_MAX_FILENAME);
}
int quasi88_printer_connect(const char *filename)
{
	quasi88_printer_remove();

	if (strlen(filename) < QUASI88_MAX_FILENAME &&
		printer_open(filename))
	{

		strcpy(file_prn, filename);
		return TRUE;
	}
	return FALSE;
}
void quasi88_printer_remove(void)
{
	printer_close();
	memset(file_prn, 0, QUASI88_MAX_FILENAME);
}
